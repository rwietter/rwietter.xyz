<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Maur√≠cio Witter | RSS Feed</title>
        <link>https://rwietterc.xyz</link>
        <description>RSS feed for Maur√≠cio Witter blog</description>
        <lastBuildDate>Mon, 07 Aug 2023 20:15:37 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>pt-BR</language>
        <image>
            <title>Maur√≠cio Witter | RSS Feed</title>
            <url>https://rwietterc.xyz/icons/mstile-310x310.png</url>
            <link>https://rwietterc.xyz</link>
        </image>
        <copyright>All rights reserved 2023, Maur√≠cio Witter</copyright>
        <atom:link href="https://rwietterc.xyz/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Um paralelo entre Programa√ß√£o Declarativa e Programa√ß√£o Imperativa]]></title>
            <link>https://rwietterc.xyz/blog/article/um-paralelo-entre-programacao-declarativa-e-programacao-imperativa</link>
            <guid>um-paralelo-entre-programacao-declarativa-e-programacao-imperativa</guid>
            <pubDate>Mon, 17 Jul 2023 15:13:39 GMT</pubDate>
            <description><![CDATA[Quais s√£o os trade-offs entre o Paradigma Imperativo e o Paradigma Declarativo, princ√≠pios e uso]]></description>
            <content:encoded><![CDATA[<h2>Introdu√ß√£o</h2>
<p>As linguagens de programa√ß√£o podem ser classificadas de diversas formas, podem ser classificadas por Type System forte ou fraco; pelo n√≠vel de abstra√ß√£o (Machine code, Low level Assembler ou High level); se s√£o compiladas ou interpretadas, ou por Paradigmas (Orienta√ß√£o a Objetos, Funcional, Procedural, L√≥gico, Imperativo, Declarativo entre outros). Neste artigo falaremos sobre o Paradigma Imperativo e Declarativo.</p>
<p>Entender o que s√£o os paradigmas de programa√ß√£o, suas caracter√≠sticas vai ajudar voc√™ a entender melhor outros paradigmas como o Paradigma Funcional, L√≥gico, ou Orientado a Objetos, pois todos eles tem alguma similaridade com os paradigmas declarativo, declarativo ou ambos.</p>
<p>O Paradigma Imperativo foi o primeiro estilo de codifica√ß√£o que surgiu, com as primeiras linguagens de estudo short code. J√° o estilo declarativo come√ßou com a linguagem LISP (1958), com o Prolog (1972), e funcionais como o Haskell (1990).</p>
<p>No lado das linguagens imperativas temos, por exemplo, FORTRAN, ALGOL, Pascal, Ada e C entre outras, j√° no lado da linguagens declarativas temos, por exemplo: HTML, CSS, YAML e SQL. As linguagens JavaScript, Java, PHP e Rust, por exemplo, s√£o multiparadigma e o estilo depende de como voc√™ escreve, mas nenhuma delas √© puramente declarativa.</p>
<h2>Estilo de Programa√ß√£o Imperativo</h2>
<p>O estilo imperativo concentra-se em como executar o c√≥digo detalhe a detalhe e define o fluxo de controle de como instru√ß√µes alteram o estado de um programa. Para ficar mais claro, o c√≥digo imperativo ordena comandos ao computador, diz exatamente o que precisa fazer, como precisa fazer e em que ordem exata precisa executar.</p>
<p>A exemplo, o c√≥digo abaixo √© um algoritmo de ordena√ß√£o chamado de bubble Sort que percorre o array <code>n^2</code> fazendo a troca dos elementos at√© orden√°-lo completamente. Nesse c√≥digo h√° a constru√ß√£o da l√≥gica e fluxo de controle, al√©m da mutabilidade do array.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0a640f32-3aa6-4420-a048-16e4174e1a81_1348x1350.png" alt="bubble sort"></p>
<p>O c√≥digo imperativo √© interessante para programa√ß√£o de c√≥digo de baixo n√≠vel para o qual existem poucas ou nenhuma abstra√ß√£o. O c√≥digo fica extremamente verboso, ruim para depurar, ler e para dar manuten√ß√£o. Em um c√≥digo imperativo h√° muitos loops, condicionais e muta√ß√µes de estado que facilmente resultam em bugs.</p>
<p>Assim sendo, a programa√ß√£o imperativa √© mais adequada para tarefas onde √© importante controlar o estado do programa e gerenciar o fluxo de execu√ß√£o.</p>
<p>Vamos calcular o fatorial de um n√∫mero natural positivo, cuja f√≥rmula est√° na imagem abaixo.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff5c2b102-a99c-45d4-a8ee-71d106821de5_487x157.png" alt="fatorial"></p>
<p>No fatorial imperativo, avaliamos se <code>n</code> √© menor ou igual a zero e retornamos 1, do contr√°rio fazemos um loop at√© <code>n-1</code> e multiplicamos o valor de <code>n</code> pelo √≠ndice fazendo a mutabilidade de <code>n</code>, ao final retornamos <code>n</code>. Nesse c√≥digo criamos a l√≥gica de calcular o fatorial de <code>n</code> e o fluxo de controle.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F36ca5586-ae84-49f3-9be8-23b7b7e716d9_1040x630.png" alt="fatorial imperativo"></p>
<h3>Caracter√≠sticas do c√≥digo Imperativo</h3>
<ul>
<li>Execu√ß√£o sequencial;</li>
<li>Estado mut√°vel;</li>
<li>Gerenciamento manual de mem√≥ria;</li>
<li>N√£o-determin√≠stico.</li>
</ul>
<h3>Vantagens</h3>
<ul>
<li>Dom√≠nio expl√≠cito sobre o fluxo de controle;</li>
<li>Efici√™ncia em uso de mem√≥ria (se utilizado corretamente);</li>
</ul>
<h3>Desvantagens</h3>
<ul>
<li>C√≥digo verboso;</li>
<li>Mutabilidade de estado;</li>
<li>Efeitos colaterais.</li>
</ul>
<h2>Paradigma Declarativo</h2>
<p>O Paradigma declarativo, por outro lado, √© um modelo de abstra√ß√£o de alto n√≠vel. Nesse estilo, declara-se o que deve ser computado ao inv√©s de como deve ser computado, delegamos a implementa√ß√£o de controle para a linguagem.</p>
<p>Assim, a programa√ß√£o declarativa √© como escrever um mapa detalhado para chegar a um destino. Voc√™ define o objetivo e descreve as etapas necess√°rias para alcan√ß√°-lo, permitindo que o computador determine a melhor rota e execute as a√ß√µes correspondentes, sem precisar se preocupar com os detalhes de como cada passo √© realizado.</p>
<p>Muitas linguagens que aplicam esse estilo tentam eliminar os efeitos colaterais descrevendo o que o programa deve realizar em termos do dom√≠nio do problema, em vez de descrever como realiz√°-lo como uma sequ√™ncia das primitivas da linguagem de programa√ß√£o.</p>
<p>Conforme R. Kowalski em Communications of the ACM, Volume 22, Issue 7, July 1979, <em>um algoritmo √© composto pela l√≥gica e pelo fluxo de controle. Na programa√ß√£o declarativa, a linguagem tende a abstrair a fluxo de controle e deixar para o programador desenvolver a l√≥gica</em>.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F649d082d-40e8-4567-b23f-3779291ec802_452x59.png" alt="algorithm"></p>
<p>Lloyd, JW. no artigo Practical advantages of declarative programming, explica que a programa√ß√£o declarativa pode ser entendida como ‚ÄúForte‚Äù e ‚ÄúFraca‚Äù. Isto √©, no sentido ‚ÄúForte‚Äù, o programador s√≥ fornece a l√≥gica do que precisa e no sentido ‚ÄúFraco‚Äù, o programador precisa fornecer a l√≥gica e estender o fluxo de controle para computar o resultado esperado.</p>
<h3>Princ√≠pios da Programa√ß√£o Declarativa</h3>
<p>Para alcan√ßar o estilo declarativo de programa√ß√£o, √© necess√°rio que alguns conceitos sejam aplicados. Os principais princ√≠pios deste paradigma s√£o: <em>Stateless</em>, <em>Transpar√™ncia referencial</em>, <em>Abstra√ß√£o</em> e <em>Aus√™ncia de efeitos colaterais</em>.</p>
<p><img src="https://i.imgur.com/aJz3ZYr.png" alt="pilares da programa√ß√£o declarativa"></p>
<h4>Stateless</h4>
<p>Em uma linguagem onde todos os dados s√£o imut√°veis, aplica-se o conceito de stateless. Isso significa que, uma vez que uma vari√°vel √© atribu√≠da, seu valor n√£o pode ser alterado. Em vez disso, qualquer manipula√ß√£o ou transforma√ß√£o de dados envolve o retorno de uma c√≥pia dos valores originais transformados, de forma que os valores originais sem mantenham intactos. Em outras palavras, n√£o fazemos a persist√™ncia dos dados entre as chamadas de execu√ß√µes. Em JavaScript, fun√ß√µes como <code>map</code>, <code>filter</code> e <code>flatMap</code>s√£o stateless e fun√ß√µes como <code>sort</code> s√£o stateful.</p>
<blockquote>
<p>Uma fun√ß√£o sem estado √© aquela que n√£o depende ou manipula o estado de contexto mais amplo. Ele pega tudo o que precisa como par√¢metro e retorna um resultado, sem efeitos colaterais e nada armazenado entre as chamadas de execu√ß√µes.</p>
</blockquote>
<p>Conforme Nick Samoylov em <a href="https://www.oreilly.com/library/view/introduction-to-programming/9781788839129/50f54a6f-dd25-40bc-89d2-31b73d95b6b7.xhtml">Introduction to Programming</a>, as opera√ß√µes sem estado geralmente n√£o representam um problema ao alternar de um fluxo sequencial para um paralelo. Cada elemento √© processado de forma independente e o stream pode ser dividido em qualquer n√∫mero de substreams para processamento independente. Ou seja, o stateless acaba com bugs e race conditions em ambientes multithreading, n√£o h√° raz√µes para usar locks para sincronizar eventos dependentes.</p>
<h4>Transpar√™ncia Referencial</h4>
<p>O valor de uma aplica√ß√£o de fun√ß√£o independe do contexto em que ocorre, isto √©, dado um input a fun√ß√£o deve retornar sempre o mesmo resultado. Por isso, a fun√ß√£o deve ser independente do contexto, de forma que n√£o use vari√°veis ou estados globais.</p>
<p>A fun√ß√£o <code>add</code> n√£o √© referencialmente transparente pois dado o mesmo argumento, ela produz resultados diferentes:</p>
<pre><code>let total = 0

const add = a => total += a

const r1  = add(1) // 1
const r2  = add(1) // 2
</code></pre>
<p>Uma fun√ß√£o ou express√£o √© referencialmente transparente se puder ser substitu√≠da por seu valor sem alterar o comportamento do programa.</p>
<h4>Abstra√ß√£o</h4>
<p>A abstra√ß√£o √© um dos principais sen√£o o principal princ√≠pio do Paradigma Declarativo, √© a primeira coisa que vem a mente quando pensamos nela. Como j√° foi dito, dizemos o que queremos e n√£o como queremos, assim delegamos a responsabilidade do que fazer para a linguagem de programa√ß√£o e apenas descrevemos como queremos o resultado a partir de determinada entrada.</p>
<p>Existem linguagens puramente declarativas, linguagens hibridas e multiparadigmas. YAML, SQL, HTML e XML s√£o exemplos de linguagens puramente declarativas. Linguagens puramente funcionais ou l√≥gicas como Haskell e Prolog, respectivamente, s√£o hibridas pois apesar de ter seus pr√≥prios paradigmas (funcional e l√≥gico) enfatizam a programa√ß√£o declarativa. J√° as linguagens como Javascript, Java, PHP s√£o multiparadigma, elas incluem algumas abstra√ß√µes declarativas mas tamb√©m incluem instru√ß√µes imperativas e n√£o opinam sobre qual meio usar.</p>
<h4>Aus√™ncia de efeitos colaterais</h4>
<p>Efeitos colaterais s√£o altera√ß√µes de estado ou execu√ß√£o de fun√ß√µes que n√£o est√£o diretamente ligadas com a produ√ß√£o do resultado esperado de uma fun√ß√£o. O Paradigma declarativo tem como objetivo eliminar as mudan√ßas de estado em vari√°veis globais ou objetos compartilhados. Em vez disso, ela se concentra em avaliar express√µes e produzir resultados imut√°veis, o que ajuda a evitar problemas relacionados a estado e concorr√™ncia.</p>
<p>A fun√ß√£o <code>doSomething</code> √© considerada referencialmente transparente porque sempre retorna o mesmo valor de sa√≠da para uma determinada entrada, e n√£o depende de nenhum estado externo. No entanto, apesar de ser referencialmente transparente, a fun√ß√£o possui um side effect, ou seja, uma a√ß√£o colateral que ocorre al√©m da simples computa√ß√£o do valor de retorno, o side effect n√£o faz parte da computa√ß√£o do valor de retorno da fun√ß√£o, mas pode ter efeitos observ√°veis fora do escopo da fun√ß√£o.</p>
<pre><code>const doSomething = (arg) => {
  console.log("something");
  return arg;
}
</code></pre>
<h3>Caracter√≠sticas do c√≥digo Declarativo</h3>
<ul>
<li>Stateless (estado interno n√£o √© relembrado entre chamadas);</li>
<li>Determin√≠stico (as mesmas chamadas produzem os mesmos resultados);</li>
<li>Paralelismo (execu√ß√£o de m√∫ltiplas tarefas simultaneamente);</li>
<li>Transpar√™ncia Referencial (uma express√£o pode ser substitu√≠da por seu valor sem afetar o comportamento);</li>
<li>Modelo sem√¢ntico claro e conciso;</li>
<li>Abstra√ß√µes de alto n√≠vel;</li>
<li>Independ√™ncia.</li>
</ul>
<h3>Vantagens</h3>
<ul>
<li>Legibilidade;</li>
<li>Concis√£o;</li>
<li>Recupera√ß√£o de erros;</li>
<li>Reutiliza√ß√£o;</li>
<li>Comutatividade;</li>
<li>Sem efeitos colaterais;</li>
<li>Idempot√™ncia.</li>
</ul>
<h3>Desvantagens</h3>
<ul>
<li>Baixo n√≠vel de controle;</li>
<li>Dificuldades de programa√ß√£o com estado (Stateful).</li>
</ul>
<h2>Use Cases</h2>
<p>Voc√™ como Engenheiro de Software precisa conhecer bem as diversas classifica√ß√µes de linguagens e suas tecnologias para fazer boas escolhas e evitar tempo e dinheiro perdido. N√£o existe bala de prata, portanto √© necess√°rio conhecer as carater√≠sticas em geral. Aqui est√£o alguns casos de uso para cada estilo, embora existem muitos outros cen√°rios.</p>
<h3>Paradigma Imperativo</h3>
<ul>
<li>Sistemas de baixo n√≠vel: programa√ß√£o de sistemas de baixo n√≠vel, como drivers de dispositivo, sistemas operacionais e firmware. Essas tarefas requerem manipula√ß√£o direta de locais de mem√≥ria e registros de hardware, sendo melhor realizado usando um estilo imperativo.</li>
<li>Jogos e simula√ß√µes: jogos e simula√ß√µes geralmente envolvem algoritmos complexos e atualiza√ß√µes em tempo real, sendo mais f√°ceis de expressar usando um estilo imperativo. A programa√ß√£o imperativa fornece controle expl√≠cito sobre o fluxo do programa, tornando mais f√°cil escrever mecanismos de jogo eficientes e simula√ß√µes f√≠sicas.</li>
<li>Opera√ß√µes de E/S: a programa√ß√£o imperativa √© adequada para tarefas que envolvem muitos estados mut√°veis ‚Äã‚Äãe efeitos colaterais, como opera√ß√µes de E/S. Programas imperativos podem manipular diretamente locais de mem√≥ria e registros de dispositivos, tornando-os adequados para essas tarefas.</li>
</ul>
<h3>Paradigma Declarativo</h3>
<ul>
<li>Desenvolvimento Web: a programa√ß√£o declarativa √© frequentemente usada no desenvolvimento Web, onde HTML, CSS e outras linguagens de marca√ß√£o s√£o usadas para definir a estrutura e a apar√™ncia das p√°ginas da Web. A programa√ß√£o declarativa permite que os desenvolvedores especifiquem a apar√™ncia da p√°gina, em vez de como obter essa apar√™ncia.</li>
<li>Processamento de dados: a programa√ß√£o declarativa √© adequada para tarefas de processamento de dados, como consultar bancos de dados e manipular grandes conjuntos de dados. Linguagens de programa√ß√£o declarativas como SQL fornecem uma interface de alto n√≠vel para interagir com dados, tornando mais f√°cil escrever consultas e transforma√ß√µes complexas.</li>
<li>Programa√ß√£o funcional: a programa√ß√£o funcional enfatiza o uso de fun√ß√µes puras e estruturas de dados imut√°veis. A programa√ß√£o funcional √© adequada para tarefas que exigem muita simultaneidade ou paralelismo, pois fun√ß√µes puras n√£o t√™m efeitos colaterais e podem ser executadas em paralelo com seguran√ßa.</li>
</ul>
<h2>Estado da Arte</h2>
<blockquote>
<p>A crescente popularidade das linguagens de programa√ß√£o declarativas decorre da simplicidade inerente do paradigma, cujo alto n√≠vel de abstra√ß√£o garante estilos de programa√ß√£o leg√≠veis por humanos. ‚Äî MOTTOLA A.. Design and implementation of a declarative programming language in a reactive environment. 2005.</p>
</blockquote>
<p>Muitas das linguagens imperativas come√ßaram a trazer novos recursos na √∫ltima d√©cada para o estilo declarativo. Um exemplo √© o Java 8 que trouce uma nova API para Streams para operar em cole√ß√µes usando express√µes lambda abstraindo o c√≥digo imperativo.</p>
<p>No Front-end tamb√©m ganhamos muito mais produtividade e seguran√ßa com os frameworks declarativos que surgiram nos √∫ltimos anos, como o React, o Vue, o Angular, o Next, o Nuxt entre outros.</p>
<p>Na √°rea de cloud-computing, v√°rias ferramentas no estilo declarativo como o Terraform, Ansible, Docker, Kubernetes auxiliam a colocar aplica√ß√µes em produ√ß√£o com escalabilidade, seguran√ßa e confiabilidade, fazendo o CI/CD.</p>
<h2>Conclus√£o</h2>
<p>√Ä medida que a programa√ß√£o declarativa continua a evoluir, √© prov√°vel que ela desempenhe um papel cada vez mais importante no futuro do desenvolvimento de software. Portanto, aprender sobre programa√ß√£o declarativa pode ser um investimento valioso para qualquer desenvolvedor que deseja melhorar sua habilidade em criar c√≥digo de qualidade.</p>
<p>Se voc√™ chegou at√© aqui, espero que tenha tido uma √≥tima leitura e que esse conte√∫do possa ter lhe ajudado de alguma forma. Obrigado por ler! Qualquer d√∫vida, agrega√ß√£o ou corre√ß√£o, <a href="https://twitter.com/rwietter">envie-me uma dm no twitter </a>.</p>
<h2>Refer√™ncias</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Declarative_programming#:~:text=Declarative%20programming%20is%20a%20non,by%20a%20declarative%20programming%20style.">Declarative Programming</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/359131.359136">Algorithm = logic + control</a></li>
<li><a href="https://www.cse.chalmers.se/~oloft/Papers/wm96.pdf">A Note on Declarative Programming Paradigms and the Future of Definitional Programming</a></li>
<li><a href="https://research-information.bris.ac.uk/en/publications/practical-advantages-of-declarative-programming">Practical advantages of declarative programming</a></li>
<li><a href="https://codedocs.org/what-is/declarative-programming">CodeDocs - Declarative programming</a></li>
<li><a href="https://blog.ndepend.com/imperative-programming-in-depth/">Imperative Programming in Depth</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maur√≠cio Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1677368314/alexander_ant_r7xd_S9hj_YYE_ae767132f4.webp"/>
        </item>
        <item>
            <title><![CDATA[Preferir a duplica√ß√£o sobre a abstra√ß√£o √© realmente o melhor caminho ?]]></title>
            <link>https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho</link>
            <guid>preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho</guid>
            <pubDate>Mon, 29 May 2023 01:45:54 GMT</pubDate>
            <description><![CDATA[A duplica√ß√£o de c√≥digo √© algo muito ruim, uma abstra√ß√£o confusa √© t√£o ruim quanto. Ent√£o qual seria a melhor abordagem para isso ?]]></description>
            <content:encoded><![CDATA[<p>Hoje vamos falar um pouco do princ√≠pio do desenvolvimento de software DRY (Don't Repeat Yourself) e suas implica√ß√µes. O DRY √© um princ√≠pio relacionado duplica√ß√£o de c√≥digo e abstra√ß√µes. Falaremos sobre o conceito de Rule of Three proposto por <a href="https://martinfowler.com/">Martin Fowler</a> no seu livro Refactoring, falaremos sobre o conceito AHA (Avoid Hasty Abstractions) proposto por <a href="https://kentcdodds.com/">Kent C. Dodds</a> e, tamb√©m, sobre conceito <a href="https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33">WET</a> (Write Everything Twice) proposto por <a href="https://dev.to/wuz">Conlin Durbin</a>.</p>
<p>Antes de tudo, vamos ver um exemplo do que seria duplica√ß√£o de c√≥digo para entender a exist√™ncia desses conceitos.</p>
<p>A duplica√ß√£o de c√≥digo (a.k.a copiar/colar), nada mais √© do que <strong>repetir o mesmo c√≥digo em dois ou mais locais da base de c√≥digo</strong>, essa duplica√ß√£o traz consigo uma <strong>s√©rie de problemas</strong>, entre eles, a <strong>redund√¢ncia de c√≥digo, bugs no c√≥digo repetido em diferentes componentes e a cria√ß√£o de bugs ao dar manuten√ß√£o em uma das duplica√ß√µes e esquecer a outra</strong>.</p>
<p>Em Ci√™ncia da Computa√ß√£o, <strong>a abstra√ß√£o √© a simplifica√ß√£o de conceitos complexos e gerais em uma interface simples</strong>, tornando-os mais f√°ceis de entender e manipular em diferentes contextos.</p>
<h2>O problema da duplica√ß√£o</h2>
<p>Suponha que temos 4 bot√µes com CSS repetido em cada um deles, a√≠ chega um requisito para mudar o background do bot√£o e quem vai dar manuten√ß√£o √© outro desenvolvedor que n√£o sabe se o c√≥digo est√° repetido, onde est√° repetido e quantas vezes est√° repetido, j√° viu o problema n√£o √© ? Teremos bot√µes de cor <code>#XXX</code> e bot√µes de cor <code>#YYY</code>.</p>
<p>Agora, <strong>imagine se o cen√°rio n√£o for um simples bot√£o, mas algo cr√≠tico para o software</strong> como a gera√ß√£o de JSON Web Token no login. Se esse c√≥digo estiver repetido e alterarmos algo em um local em outro n√£o, podemos ter problemas de vulnerabilidades ou diversos outros bugs que dependem do token.</p>
<p>A abstra√ß√£o errada, na realidade n√£o passa de um c√≥digo confuso e mal escrito. A abstra√ß√£o errada √© uma abstra√ß√£o que n√£o deveria existir. Ent√£o, seria melhor deixar o c√≥digo repetido ao inv√©s de fazer uma abstra√ß√£o complexa ? Talvez! Mas na maioria das vezes √© apenas um erro de implementa√ß√£o ao definir v√°rias responsabilidades a ela ou abstrair conhecimentos distintos.</p>
<h2>Princ√≠pios gerais</h2>
<p>Ent√£o, quando devemos duplicar c√≥digo e quando devemos abstrair ? Essas perguntas tem muitas respostas, mas nenhuma √© realmente um padr√£o convencional que todos os desenvolvedores adotam.</p>
<h3>Don't Repeat Yourself</h3>
<p>O DRY foi um princ√≠pio formulado por Andy Hunt e Dave Thomas, no livro <a href="https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X">The Pragmatic Programmer</a>. Conforme os autores, o DRY surgiu para tentar resolver Os Males da Duplica√ß√£o (The Evils of Duplication). Se voc√™ tem c√≥digo duplicado, voc√™ precisa lembrar-se onde duplicou, mas n√£o √© uma quest√£o de saber se voc√™ vai se lembrar: √© uma quest√£o de quando voc√™ vai esquecer, e a surpresa n√£o ser√° nada agrad√°vel quando acontecer.</p>
<p>Em outras palavras, quando voc√™ precisa alterar alguma coisa e o c√≥digo est√° repetido por N vezes na sua base de c√≥digo, ent√£o voc√™ ter√° que alterar em N lugares e isso nos leva ao problema descrito na se√ß√£o 1.</p>
<blockquote>
<p>‚ÄúCada fragmento de conhecimento deve ter uma representa√ß√£o √∫nica, inequ√≠voca e autorit√°ria dentro de um sistema.‚Äù (The Pragmatic Programmer).</p>
</blockquote>
<p>Conforme Hunt e Thomas, <strong>um c√≥digo que representa um conhecimento deve ter uma representa√ß√£o √∫nica, inequ√≠voca e autorit√°ria dentro de um sistema</strong>. Isso significa que DRY n√£o √© apenas sobre n√£o duplicar c√≥digo, mas √©, sobretudo, conhecimento.</p>
<p>Bem, mas o que isso significa ? Significa que dois c√≥digos duplicados podem ser iguais no momento, mas que podem crescer com seus pr√≥prios requisitos e de forma diferente, ou seja, temos dois fragmentos com representa√ß√µes √∫nicas de conhecimento, nesse caso n√£o faz sentido criar uma abstra√ß√£o pois n√£o viola o principio DRY e voc√™ pode acabar tendo uma abstra√ß√£o que representa inst√¢ncias de conhecimentos diferentes.</p>
<p>O DRY n√£o espec√≠fica quando √© a hora de abstrair uma duplica√ß√£o ou quando n√£o abstrair, voc√™ simplesmente n√£o deve repetir o mesmo conhecimento. Muitos desenvolvedores fazem abstra√ß√µes precipitadas e acabam tendo uma abstra√ß√£o complexa que tem muitas responsabilidades, tornando o c√≥digo pouco leg√≠vel, manuten√≠vel e test√°vel.</p>
<p><em>Isso nos leva ao Rule of Three‚Ä¶</em></p>
<h3>Rule of Three</h3>
<p>Esse conceito foi proposto por Martin Fowler em seu livro Refactoring.</p>
<p>Voc√™ deve estar se perguntando o porqu√™ de <strong>tr√™s</strong> ser especial. Geralmente voc√™ acaba tendo duas duplica√ß√µes com uma ou outra leve particularidade e pode ser mantida assim caso voc√™ n√£o saiba os requisitos futuros, mas quando h√° tr√™s duplica√ß√£o √© muito comum ter mais duplica√ß√µes.</p>
<blockquote>
<p>‚ÄúA primeira vez que voc√™ faz algo, voc√™ simplesmente faz. Na segunda vez que voc√™ faz algo semelhante, voc√™ pode ter calafrios com a duplica√ß√£o, mas faz a duplica√ß√£o de qualquer maneira. Na terceira vez que voc√™ fizer algo semelhante, voc√™ refatorar√°‚Äù (Martin Fowler - Refactoring).</p>
</blockquote>
<p>Rule of Three diz que voc√™ pode duplicar o c√≥digo por duas vezes, mas se voc√™ tiver que repetir pela terceira vez, ent√£o √© hora de refatorar.</p>
<h3>Write Everything Twice</h3>
<p>WET se assemelha ao conceito Rule of Three, WET tenta se afastar de otimiza√ß√µes prematuras e permite que voc√™ possa repetir c√≥digo duas vezes mas n√£o tr√™s. No entanto, aqui o sistema pode ser entendido como algo mais abstrato e a abstra√ß√£o depende do contexto.</p>
<p>Por exemplo, se voc√™ tem bot√µes que se repetem em diferentes p√°ginas, faz sentido voc√™ abstrair em um √∫nico componente. No entanto, se voc√™ tem duas p√°ginas como /blog e /listas que recebem um conjunto de dados e renderizam o t√≠tulo e descri√ß√£o, n√£o h√° essa necessidade pois s√£o componentes de conhecimento distintos.</p>
<p>Conlin Durbin enfatiza que em caso de duplica√ß√£o, voc√™ deve comentar sobre elas, para quando ocorrer um problema ou tiver que fazer uma abstra√ß√£o, seja mais f√°cil encontr√°-las.</p>
<h3>Avoid Hasty Abstractions</h3>
<p>Enfim, chegamos ao AHA que se pron√∫ncia ‚ÄúAha!‚Äù e pode se entendido como ‚ÄúEvite abstra√ß√µes precipitadas‚Äù. Esse conceito foi proposto por Kent C. Dodds em um <a href="https://kentcdodds.com/blog/aha-programming">artigo</a> no ano de 2020. Na mesma linha, Dodds sugere que <strong>devemos evitar abstra√ß√µes precipitadas pois n√£o sabemos todos os requisitos de um sistema de antem√£o</strong>, tanto que pode mudar e evoluir e voc√™ acaba com uma <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">abstra√ß√£o errada</a>, conforme cita Sandi Metz.</p>
<blockquote>
<p>‚ÄúOtimize primeiro, fa√ßa a mudan√ßa depois.‚Äù (Kent C. Dodds - AHA).</p>
</blockquote>
<p>AHA da mais flexibilidade e n√£o imp√µe regras de duplica√ß√µes para refatorar e abstrair, mas ressalta que a import√¢ncia do DRY para n√£o virar um caos absoluto. Primeiramente, diante de duplica√ß√µes, deve-se <strong>otimiz√°-las antes de mudar no sentido de abstrair com clareza</strong>. Quanto a quest√£o de quando mudar, <strong>voc√™ pode mudar quando sentir-se confiante com os casos de uso</strong>.</p>
<h2>Adapta√ß√£o</h2>
<p>A duplica√ß√£o de c√≥digo incorre em um custo muito alto na maioria das vezes, mesmo que seja no m√°ximo duas duplica√ß√µes. Talvez, se o problema √© abstra√ß√£o mal feita, ent√£o o problema √© de implementa√ß√£o. Algo que deve resolver isso √© entender como DRY trata conhecimento, para n√£o criarmos abstra√ß√µes com diversas responsabilidades. Ou seja, se voc√™ tem uma abstra√ß√£o que est√° tomando rumos diferentes, caia fora dessa abstra√ß√£o e fa√ßa outra que atende aos requisitos do novo recurso.</p>
<p>Por exemplo, temos o <strong>ComponenteA</strong> e o <strong>ComponenteB</strong>, eles s√£o uma duplica√ß√£o de c√≥digo com um padr√£o em comum e mesmo conhecimento, ent√£o criamos a Abstra√ß√£oX de forma simples e flex√≠vel por padr√£o (Imagem 1). Digamos que o ComponenteB precisa mudar e √© preciso modificar a Abstra√ß√£oX, de tal modo que adicionamos mais responsabilidade e que n√£o √© usada no ComponenteA, ou seja, isso j√° <strong>deixou de ter o mesmo conhecimento</strong> e possivelmente trar√° problemas futuros. Para resolver isso, vamos separar a Abstra√ß√£oX em Abstra√ß√£oX e Abstra√ß√£oY ou desfazer as abstra√ß√µes e retornar aos Componentes A e B.</p>
<p><img src="https://res.cloudinary.com/ddwnioveu/image/upload/v1685323229/b55d6170_0684_4f19_9f93_480f96b242b3_1344x1306_a053b70020.webp" alt="b55d6170-0684-4f19-9f93-480f96b242b3_1344x1306.webp">
.</p>
<p>Dessa forma, podemos resolver a quest√£o de abstrair sem ter que lidar duplica√ß√µes. Particularmente, as duplica√ß√µes em uma base de c√≥digo grande s√£o bem custosas. Assim, para lidarmos com abstra√ß√µes erradas, analisamos o contexto e o conhecimento, quando n√£o faz mais sentido essa abstra√ß√£o, removemos a abstra√ß√£o. N√£o precisamos ter que duplicar c√≥digo uma, duas ou tr√™s vezes a espera de abstrair e evitar dores de cabe√ßa.</p>
<p><strong>Essa √© s√≥ outra vis√£o, portanto, fica a sua escolha testar e verificar qual se sai melhor pra voc√™.</strong></p>
<h3>Al√©m disso‚Ä¶</h3>
<p><strong>Evite abstra√ß√µes excessivamente gen√©ricas</strong>, as abstra√ß√µes podem ser t√£o gen√©ricas que perdem sua utilidade. Por exemplo, criar uma abstra√ß√£o de "Animal" para um sistema que s√≥ tem um tipo de objeto ‚ÄúCachorro‚Äù pode ser excessivamente gen√©rico e n√£o agregar valor. As abstra√ß√µes devem ser espec√≠ficas e relevantes para o problema que se est√° tentando resolver.</p>
<p><strong>Evite a duplica√ß√£o de c√≥digo em testes</strong>, seus testes devem ser t√£o DRY quanto poss√≠vel e evite duplicar c√≥digo em v√°rios testes.</p>
<p>Para a evolu√ß√£o do software, <strong>as abstra√ß√µes devem ser flex√≠veis o suficiente para lidar com mudan√ßas no sistema</strong> e permitir que o software evolua sem muita dor.</p>
<p>No que tange a legibilidade do c√≥digo, <strong>as abstra√ß√µes devem tornar o c√≥digo mais leg√≠vel e n√£o o contr√°rio</strong>.</p>
<h2>Para concluir</h2>
<p>Criar abstra√ß√µes √© complicado e requer um bom entendimento do problema a ser resolvido. Se uma abstra√ß√£o n√£o for bem projetada, ela pode acabar sendo mais dif√≠cil de entender e manter do que o pr√≥prio c√≥digo duplicado.</p>
<p>No entanto, isso n√£o significa que a duplica√ß√£o de c√≥digo seja a melhor alternativa. A duplica√ß√£o pode levar a problemas de manuten√ß√£o, como corre√ß√µes duplicadas ou c√≥digo obsoleto, al√©m de dificultar a leitura e a compreens√£o do c√≥digo. A duplica√ß√£o aumenta o risco de erros, pois, se uma corre√ß√£o √© feita em um lugar, pode ser esquecido de ser feito em outro lugar onde o c√≥digo √© duplicado.</p>
<p>A solu√ß√£o para evitar a duplica√ß√£o de c√≥digo e ainda assim criar abstra√ß√µes √∫teis √© encontrar o equil√≠brio certo entre abstra√ß√£o e detalhes de implementa√ß√£o. √â importante pensar em como a abstra√ß√£o pode ser √∫til no longo prazo e se ela pode ser adaptada facilmente para futuras mudan√ßas no sistema. √â importante tamb√©m criar abstra√ß√µes que sejam simples, claras e facilmente compreens√≠veis.</p>
<h2>Refer√™ncias</h2>
<ul>
<li><a href="https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X">The Pragmatic Programmer</a></li>
<li><a href="https://www.amazon.com.br/Refactoring-Improving-Design-Existing-Code/dp/0134757599/ref=pd_lpo_1?pd_rd_w=y2LPp&#x26;content-id=amzn1.sym.036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&#x26;pf_rd_p=036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&#x26;pf_rd_r=T1Z6DP66YJS241C8ZYSX&#x26;pd_rd_wg=NXa55&#x26;pd_rd_r=4883151e-42e5-403c-981f-c973bb258c03&#x26;pd_rd_i=0134757599&#x26;psc=1">Refactoring</a></li>
<li><a href="https://kentcdodds.com/blog/aha-programming">AHA Programming</a></li>
<li><a href="https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33">Stop trying to be so DRY, instead Write Everything Twice (WET)</a></li>
<li><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">The Wrong Abstraction</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maur√≠cio Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1685324727/Tech_012_b658827d91.jpg"/>
        </item>
        <item>
            <title><![CDATA[Fluxo bidirecional no React com useImperativeHandle]]></title>
            <link>https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle</link>
            <guid>fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle</guid>
            <pubDate>Mon, 25 Apr 2022 11:59:22 GMT</pubDate>
            <description><![CDATA[Expondo uma fun√ß√£o de um componente child para o componente owner no React]]></description>
            <content:encoded><![CDATA[<h3>Introdu√ß√£o</h3>
<p>Ol√° üëã</p>
<p>Hoje vamos falar de fluxos unidirecional e bidirecional no Nextjs. Por padr√£o, no React, os dados fluem de uma maneira: do <em>owner</em> para o <em>child</em>, ou seja, no fluxo unidirecional, mas por vezes precisamos acessar determinada fun√ß√£o ou realizar uma mudan√ßa de estado em um componente <em>child</em> pelo componente <em>owner</em>, isto √©, de forma bidirecional, expondo um dado do componente inferior para o superior.</p>
<p><img src="https://raw.githubusercontent.com/rwietter/gatsby-blog/master/static/bidirecional.png" alt="fluxo bidirecional de dados dos componentes React. Componente owner passando uma propriedade ref para o componente child"></p>
<p>Para resolver isso, podemos elevar o estado (<em>Lifting State Up</em>) de um componente <em>child</em> para um componente <em>owner</em> que ir√° conter a l√≥gica do componente <em>child</em>. Outra forma √© utilizar a <em>Context API</em> ou outro gerenciador de estado global para compartilhamento de estado.  Mas, tamb√©m podemos expor uma fun√ß√£o ou estado para o componente <em>owner</em> por meio do <em>hook</em> <code>useImperativeHandle</code> e o <em>hook</em> <code>useRef</code> passando a refer√™ncia da propriedade para o componente <em>owner</em>. Vamos ver como isso funciona.</p>
<p>Conforme a documenta√ß√£o do React diz sobre o <em>hook</em> <code>useImperativeHandle</code>:</p>
<blockquote>
<p>O <em>hook</em> <code>useImperativeHandle</code>¬†personaliza o valor da inst√¢ncia que est√° exposta aos componentes <em>owner</em> ao usar¬†<code>ref</code>. Como sempre, na maioria dos casos, seria bom evitar um c√≥digo imperativo usando refs.</p>
</blockquote>
<p>E sobre o <em>hook</em> <code>useRef</code>:</p>
<blockquote>
<p><code>useRef</code>¬†retorna um objeto¬†<code>ref</code>¬†mut√°vel, no qual a propriedade¬†<code>current</code>¬†√© inicializada para o argumento passado (<code>initialValue</code>). O objeto retornado persistir√° durante todo o ciclo de vida do componente.</p>
</blockquote>
<p>Ou seja, o <em>hook</em> <code>useRef</code> cria um objeto mut√°vel que recebe um valor inicial no qual podemos mudar durante o ciclo de vida do componente, j√° o <em>hook</em>  <code>useImperativeHandle</code> vai nos ajudar a expor nossa propriedade para o componente superior de forma imperativa utilizando essa refer√™ncia.</p>
<h3>Vamos ao exemplo pr√°tico</h3>
<p>Vamos come√ßar criando um <em>app</em> com o <em>framework</em> <em>Nextjs</em>. Rode no seu terminal os comandos abaixo para criar o projeto, em seguida entre no diret√≥rio e execute a aplica√ß√£o.</p>
<pre><code># crie o projeto
yarn create next-app --typescript

# entre no diret√≥rio criado
cd my-app

# compila e executa o projeto em http://localhost:3000
yarn dev
</code></pre>
<p>Projeto criado! Agora, vamos at√© o <code>index.tsx</code> em <code>/pages/index.tsx</code> e vamos remover o c√≥digo desnecess√°rio, deixe como no exemplo abaixo.</p>
<pre><code>import type { NextPage } from 'next'

const Home: NextPage = () => {
  return (
    &#x3C;div>
 
    &#x3C;/div>
  )
}

export default Home
</code></pre>
<p>Vamos criar nosso componente <code>Modal</code>. Crie um diret√≥rio <code>components</code> na raiz do projeto e dentro dele um diret√≥rio <code>modal</code> e crie um arquivo <code>index.tsx</code>. Dentro do componente modal adicione uma <code>label</code> e um <code>input</code> com a l√≥gica de abrir o modal quando o estado for verdadeiro (<em>Short Circuit Evaluation</em>).</p>
<pre><code>// components/modal/index.tsx
import { useState } from "react";

const Modal: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    &#x3C;>
      {isModalOpen &#x26;&#x26; (
        &#x3C;div className="modal">
          &#x3C;label htmlFor="nome">Qual o seu nome ?&#x3C;/label>
          &#x3C;input name="nome" />
        &#x3C;/div>
      )}
    &#x3C;/>
  );
};

export default Modal;
</code></pre>
<p>Vamos importar o <code>Modal</code> no componente <code>Home</code> e adicionar um bot√£o logo abaixo que vai disparar um evento ao receber um <code>click</code>. Esse evento precisa mudar o estado do modal para <code>true</code> para que seja exibido em tela. Logo, precisamos referenciar a fun√ß√£o que troca o estado do modal para o componente <code>Home</code>.</p>
<pre><code>import type { NextPage } from 'next'
import Modal from '../components/modal'

const Home: NextPage = () => {
  return (
    &#x3C;main>
      &#x3C;Modal />
      &#x3C;button onClick={() => {}} className="open-modal-button">
        Open Modal
      &#x3C;/button>
    &#x3C;/main>
  )
}

export default Home
</code></pre>
<p>Antes vamos adicionar um estilo ao modal. Crie um arquivo de estilo <code>styles/modal.css</code>, esse estilo ir√° posicionar o modal sobre os outros elementos, centralizar seus componentes e adicionar uma largura e altura. Voc√™ pode copiar o CSS nesse <a href="https://github.com/rwietter/blog-posts/blob/main/my-app/styles/modal.css">link</a>.</p>
<p>No estilo <code>global.css</code> adicione o c√≥digo abaixo para centralizar o conte√∫do.</p>
<pre><code>/* styles/global.css */
main {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</code></pre>
<p>Agora basta importar o arquivo <code>modal.css</code>em <code>pages/_app.tsx</code>. Dessa forma o estilo j√° ser√° aplicado ao nosso componente <code>Modal</code>.</p>
<pre><code>// pages/_app.tsx
import '../styles/globals.css';
import '../styles/modal.css';
</code></pre>
<p>Agora precisamos fazer o fluxo inverso, vamos referenciar a fun√ß√£o que vai alterar o estado para que o componente <em>owner</em> possa acessar. No modal precisamos receber a refer√™ncia que ser√° criada no componente <em>owner</em>, essa refer√™ncia √© obtida como segundo par√¢metro, tamb√©m vamos adicionar o <strong>tipo</strong> aos nossos par√¢metros com <em>generic types</em>.  Tamb√©m, vamos expor a fun√ß√£o <code>handleOpenModal</code> com o <em>hook</em> <code>useImperativeHandle</code>, como primeiro argumento ele recebe a refer√™ncia criada no <em>owner</em>, como segundo argumento uma <em>callback</em> que ir√° retornar um objeto com nossa fun√ß√£o que queremos acessar pela refer√™ncia criada no <em>owner</em>. Por fim, vamos exportar o componente como argumento da fun√ß√£o <code>forwardRef</code>, essa fun√ß√£o ir√° encaminhar a refer√™ncia ao componente <em>owner</em>.</p>
<pre><code>import {
  forwardRef,
  ForwardRefRenderFunction,
  ReactNode,
  useImperativeHandle,
  useState,
} from "react";

interface ModalProps {
  children?: ReactNode;
}

const Modal: ForwardRefRenderFunction&#x3C;ModalRef, ModalProps> = (props, ref) => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = () => setIsModalOpen((state) => !state);
  
  useImperativeHandle(ref, () => ({
    handleOpenModal,
  }));

  return (
    &#x3C;>
      {/* ... */}
    &#x3C;/>
  )
}

export default forwardRef(Modal);
</code></pre>
<p>Agora, no componente <code>Home</code>, precisamos criar a <code>ref</code> e repassar para o componente modal.  Utilizamos o <em>hook</em> <code>useRef</code> para criar uma <code>ref</code> e passamos como <em>generic type</em> a interface <code>ModalRef</code> que espec√≠fica a fun√ß√£o que iremos referenciar. Exporte essa interface e importe no componente Modal, pois precisamos adicionar o <em>type</em> que recebemos como atributo do componente.</p>
<pre><code>export interface ModalRef {
  handleOpenModal: () => void;
}

const Home: NextPage = () => {
  const modalRef = useRef&#x3C;ModalRef>(null);

  return (
    &#x3C;>
      &#x3C;Modal ref={modalRef} />
      &#x3C;button onClick={() => {}}>Open Modal&#x3C;/button>
    &#x3C;/>
  )
}

export default Home;
</code></pre>
<p>Ainda no componente <code>Home</code>, s√≥ precisamos criar uma fun√ß√£o que ir√° receber a refer√™ncia da fun√ß√£o do <code>Modal</code> e repassar para a propriedade <code>onClick</code>. Feito isso, j√° iremos ter o modal funcional.</p>
<pre><code>const Home: NextPage = () => {
  const modalRef = useRef&#x3C;ModalRef>(null);
  const handleOpenModal = () => modalRef.current?.handleOpenModal();

  return (
    &#x3C;>
      &#x3C;Modal ref={modalRef} />
      &#x3C;button onClick={handleOpenModal}>Open Modal&#x3C;/button>
    &#x3C;/>
  )
}
</code></pre>
<p>Para finalizar, vamos adicionar um bot√£o de <code>close</code> no modal para fechar quando estiver aberto.</p>
<pre><code>return (
  &#x3C;>
    {isModalOpen &#x26;&#x26; (
      &#x3C;div className="modal">
        &#x3C;label htmlFor="nome">Qual o seu nome ?&#x3C;/label>
        &#x3C;input name="nome" />
        &#x3C;button onClick={handleOpenModal}>Close&#x3C;/button>
      &#x3C;/div>
    )}
  &#x3C;/>
);
</code></pre>
<h3>Conclus√£o</h3>
<p>Essa √© uma forma simples de alterar um estado quando n√£o podemos ou n√£o queremos criar a l√≥gica de uma funcionalidade em um componente que n√£o precisa saber dessa funcionalidade ou n√£o queremos utilizar um gerenciador de estado.  N√£o √© muito comum, nem recomend√°vel utilizar c√≥digo imperativo, mas quando necess√°rio pode ser muito √∫til :)</p>
<p>At√© mais ‚öõ üëã</p>
<hr>
<h3>Refer√™ncias</h3>
<ul>
<li><a href="https://pt-br.reactjs.org/docs/hooks-reference.html#useimperativehandle">Hook useImperativeHandle</a></li>
<li><a href="https://pt-br.reactjs.org/docs/hooks-reference.html#useref">Hook useRef</a></li>
<li><a href="https://pt-br.reactjs.org/docs/react-api.html#reactforwardref">ForwardRef</a></li>
<li><a href="https://github.com/rwietter/blog-posts/tree/main/my-app">Reposit√≥rio do projeto</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maur√≠cio Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1676138698/hubble_arp_madore608_333_potw2240a_1_36bdc3a340.jpg"/>
        </item>
    </channel>
</rss>
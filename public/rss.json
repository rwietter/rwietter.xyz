{
    "version": "https://jsonfeed.org/version/1",
    "title": "Maur√≠cio Witter | RSS Feed",
    "home_page_url": "https://rwietterc.xyz",
    "feed_url": "https://rwietterc.xyz/rss.json",
    "description": "RSS feed for Maur√≠cio Witter blog",
    "icon": "https://rwietterc.xyz/icons/mstile-310x310.png",
    "author": {
        "name": "Maur√≠cio Witter",
        "url": "https://twitter.com/rwietter"
    },
    "items": [
        {
            "id": "https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho",
            "content_html": "Hoje vamos falar um pouco do princ√≠pio do desenvolvimento de software DRY (Don't Repeat Yourself) e suas implica√ß√µes. O DRY √© um princ√≠pio relacionado duplica√ß√£o de c√≥digo e abstra√ß√µes. Falaremos sobre o conceito de Rule of Three proposto por [Martin Fowler](https://martinfowler.com/) no seu livro Refactoring, falaremos sobre o conceito AHA (Avoid Hasty Abstractions) proposto por [Kent C. Dodds](https://kentcdodds.com/) e, tamb√©m, sobre conceito [WET](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33) (Write Everything Twice) proposto por [Conlin Durbin](https://dev.to/wuz).\n\nAntes de tudo, vamos ver um exemplo do que seria duplica√ß√£o de c√≥digo para entender a exist√™ncia desses conceitos.\n\nA duplica√ß√£o de c√≥digo (a.k.a copiar/colar), nada mais √© do que **repetir o mesmo c√≥digo em dois ou mais locais da base de c√≥digo**, essa duplica√ß√£o traz consigo uma **s√©rie de problemas**, entre eles, a **redund√¢ncia de c√≥digo, bugs no c√≥digo repetido em diferentes componentes e a cria√ß√£o de bugs ao dar manuten√ß√£o em uma das duplica√ß√µes e esquecer a outra**.\n\nEm Ci√™ncia da Computa√ß√£o, **a abstra√ß√£o √© a simplifica√ß√£o de conceitos complexos e gerais em uma interface simples**, tornando-os mais f√°ceis de entender e manipular em diferentes contextos.\n\n## O problema da duplica√ß√£o\n\nSuponha que temos 4 bot√µes com CSS repetido em cada um deles, a√≠ chega um requisito para mudar o background do bot√£o e quem vai dar manuten√ß√£o √© outro desenvolvedor que n√£o sabe se o c√≥digo est√° repetido, onde est√° repetido e quantas vezes est√° repetido, j√° viu o problema n√£o √© ? Teremos bot√µes de cor `#XXX` e bot√µes de cor `#YYY`.\n\nAgora, **imagine se o cen√°rio n√£o for um simples bot√£o, mas algo cr√≠tico para o software** como a gera√ß√£o de JSON Web Token no login. Se esse c√≥digo estiver repetido e alterarmos algo em um local em outro n√£o, podemos ter problemas de vulnerabilidades ou diversos outros bugs que dependem do token.\n\nA abstra√ß√£o errada, na realidade n√£o passa de um c√≥digo confuso e mal escrito. A abstra√ß√£o errada √© uma abstra√ß√£o que n√£o deveria existir. Ent√£o, seria melhor deixar o c√≥digo repetido ao inv√©s de fazer uma abstra√ß√£o complexa ? Talvez! Mas na maioria das vezes √© apenas um erro de implementa√ß√£o ao definir v√°rias responsabilidades a ela ou abstrair conhecimentos distintos.\n\n## Princ√≠pios gerais\n\nEnt√£o, quando devemos duplicar c√≥digo e quando devemos abstrair ? Essas perguntas tem muitas respostas, mas nenhuma √© realmente um padr√£o convencional que todos os desenvolvedores adotam.\n\n### Don't Repeat Yourself\n\nO DRY foi um princ√≠pio formulado por Andy Hunt e Dave Thomas, no livro [The Pragmatic Programmer](https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X). Conforme os autores, o DRY surgiu para tentar resolver Os Males da Duplica√ß√£o (The Evils of Duplication). Se voc√™ tem c√≥digo duplicado, voc√™ precisa lembrar-se onde duplicou, mas n√£o √© uma quest√£o de saber se voc√™ vai se lembrar: √© uma quest√£o de quando voc√™ vai esquecer, e a surpresa n√£o ser√° nada agrad√°vel quando acontecer.\n\nEm outras palavras, quando voc√™ precisa alterar alguma coisa e o c√≥digo est√° repetido por N vezes na sua base de c√≥digo, ent√£o voc√™ ter√° que alterar em N lugares e isso nos leva ao problema descrito na se√ß√£o 1.\n\n\n> ‚ÄúCada fragmento de conhecimento deve ter uma representa√ß√£o √∫nica, inequ√≠voca e autorit√°ria dentro de um sistema.‚Äù (The Pragmatic Programmer).\n\nConforme Hunt e Thomas, **um c√≥digo que representa um conhecimento deve ter uma representa√ß√£o √∫nica, inequ√≠voca e autorit√°ria dentro de um sistema**. Isso significa que DRY n√£o √© apenas sobre n√£o duplicar c√≥digo, mas √©, sobretudo, conhecimento.\n\nBem, mas o que isso significa ? Significa que dois c√≥digos duplicados podem ser iguais no momento, mas que podem crescer com seus pr√≥prios requisitos e de forma diferente, ou seja, temos dois fragmentos com representa√ß√µes √∫nicas de conhecimento, nesse caso n√£o faz sentido criar uma abstra√ß√£o pois n√£o viola o principio DRY e voc√™ pode acabar tendo uma abstra√ß√£o que representa inst√¢ncias de conhecimentos diferentes.\n\nO DRY n√£o espec√≠fica quando √© a hora de abstrair uma duplica√ß√£o ou quando n√£o abstrair, voc√™ simplesmente n√£o deve repetir o mesmo conhecimento. Muitos desenvolvedores fazem abstra√ß√µes precipitadas e acabam tendo uma abstra√ß√£o complexa que tem muitas responsabilidades, tornando o c√≥digo pouco leg√≠vel, manuten√≠vel e test√°vel.\n\n_Isso nos leva ao Rule of Three‚Ä¶_\n\n### Rule of Three\n\nEsse conceito foi proposto por Martin Fowler em seu livro Refactoring.\n\nVoc√™ deve estar se perguntando o porqu√™ de **tr√™s** ser especial. Geralmente voc√™ acaba tendo duas duplica√ß√µes com uma ou outra leve particularidade e pode ser mantida assim caso voc√™ n√£o saiba os requisitos futuros, mas quando h√° tr√™s duplica√ß√£o √© muito comum ter mais duplica√ß√µes.\n\n\n> ‚ÄúA primeira vez que voc√™ faz algo, voc√™ simplesmente faz. Na segunda vez que voc√™ faz algo semelhante, voc√™ pode ter calafrios com a duplica√ß√£o, mas faz a duplica√ß√£o de qualquer maneira. Na terceira vez que voc√™ fizer algo semelhante, voc√™ refatorar√°‚Äù (Martin Fowler - Refactoring).\n\nRule of Three diz que voc√™ pode duplicar o c√≥digo por duas vezes, mas se voc√™ tiver que repetir pela terceira vez, ent√£o √© hora de refatorar.\n\n### Write Everything Twice\n\nWET se assemelha ao conceito Rule of Three, WET tenta se afastar de otimiza√ß√µes prematuras e permite que voc√™ possa repetir c√≥digo duas vezes mas n√£o tr√™s. No entanto, aqui o sistema pode ser entendido como algo mais abstrato e a abstra√ß√£o depende do contexto.\n\nPor exemplo, se voc√™ tem bot√µes que se repetem em diferentes p√°ginas, faz sentido voc√™ abstrair em um √∫nico componente. No entanto, se voc√™ tem duas p√°ginas como /blog e /listas que recebem um conjunto de dados e renderizam o t√≠tulo e descri√ß√£o, n√£o h√° essa necessidade pois s√£o componentes de conhecimento distintos.\n\nConlin Durbin enfatiza que em caso de duplica√ß√£o, voc√™ deve comentar sobre elas, para quando ocorrer um problema ou tiver que fazer uma abstra√ß√£o, seja mais f√°cil encontr√°-las.\n\n### Avoid Hasty Abstractions\n\nEnfim, chegamos ao AHA que se pron√∫ncia ‚ÄúAha!‚Äù e pode se entendido como ‚ÄúEvite abstra√ß√µes precipitadas‚Äù. Esse conceito foi proposto por Kent C. Dodds em um [artigo](https://kentcdodds.com/blog/aha-programming) no ano de 2020. Na mesma linha, Dodds sugere que **devemos evitar abstra√ß√µes precipitadas pois n√£o sabemos todos os requisitos de um sistema de antem√£o**, tanto que pode mudar e evoluir e voc√™ acaba com uma [abstra√ß√£o errada](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction), conforme cita Sandi Metz.\n\n> ‚ÄúOtimize primeiro, fa√ßa a mudan√ßa depois.‚Äù (Kent C. Dodds - AHA).\n\nAHA da mais flexibilidade e n√£o imp√µe regras de duplica√ß√µes para refatorar e abstrair, mas ressalta que a import√¢ncia do DRY para n√£o virar um caos absoluto. Primeiramente, diante de duplica√ß√µes, deve-se **otimiz√°-las antes de mudar no sentido de abstrair com clareza**. Quanto a quest√£o de quando mudar, **voc√™ pode mudar quando sentir-se confiante com os casos de uso**.\n\n## Adapta√ß√£o\n\nA duplica√ß√£o de c√≥digo incorre em um custo muito alto na maioria das vezes, mesmo que seja no m√°ximo duas duplica√ß√µes. Talvez, se o problema √© abstra√ß√£o mal feita, ent√£o o problema √© de implementa√ß√£o. Algo que deve resolver isso √© entender como DRY trata conhecimento, para n√£o criarmos abstra√ß√µes com diversas responsabilidades. Ou seja, se voc√™ tem uma abstra√ß√£o que est√° tomando rumos diferentes, caia fora dessa abstra√ß√£o e fa√ßa outra que atende aos requisitos do novo recurso.\n\nPor exemplo, temos o **ComponenteA** e o **ComponenteB**, eles s√£o uma duplica√ß√£o de c√≥digo com um padr√£o em comum e mesmo conhecimento, ent√£o criamos a Abstra√ß√£oX de forma simples e flex√≠vel por padr√£o (Imagem 1). Digamos que o ComponenteB precisa mudar e √© preciso modificar a Abstra√ß√£oX, de tal modo que adicionamos mais responsabilidade e que n√£o √© usada no ComponenteA, ou seja, isso j√° **deixou de ter o mesmo conhecimento** e possivelmente trar√° problemas futuros. Para resolver isso, vamos separar a Abstra√ß√£oX em Abstra√ß√£oX e Abstra√ß√£oY ou desfazer as abstra√ß√µes e retornar aos Componentes A e B.\n\n![b55d6170-0684-4f19-9f93-480f96b242b3_1344x1306.webp](https://res.cloudinary.com/ddwnioveu/image/upload/v1685323229/b55d6170_0684_4f19_9f93_480f96b242b3_1344x1306_a053b70020.webp)\n.\n\nDessa forma, podemos resolver a quest√£o de abstrair sem ter que lidar duplica√ß√µes. Particularmente, as duplica√ß√µes em uma base de c√≥digo grande s√£o bem custosas. Assim, para lidarmos com abstra√ß√µes erradas, analisamos o contexto e o conhecimento, quando n√£o faz mais sentido essa abstra√ß√£o, removemos a abstra√ß√£o. N√£o precisamos ter que duplicar c√≥digo uma, duas ou tr√™s vezes a espera de abstrair e evitar dores de cabe√ßa.\n\n**Essa √© s√≥ outra vis√£o, portanto, fica a sua escolha testar e verificar qual se sai melhor pra voc√™.**\n\n### Al√©m disso‚Ä¶\n\n**Evite abstra√ß√µes excessivamente gen√©ricas**, as abstra√ß√µes podem ser t√£o gen√©ricas que perdem sua utilidade. Por exemplo, criar uma abstra√ß√£o de \"Animal\" para um sistema que s√≥ tem um tipo de objeto ‚ÄúCachorro‚Äù pode ser excessivamente gen√©rico e n√£o agregar valor. As abstra√ß√µes devem ser espec√≠ficas e relevantes para o problema que se est√° tentando resolver.\n\n**Evite a duplica√ß√£o de c√≥digo em testes**, seus testes devem ser t√£o DRY quanto poss√≠vel e evite duplicar c√≥digo em v√°rios testes.\n\nPara a evolu√ß√£o do software, **as abstra√ß√µes devem ser flex√≠veis o suficiente para lidar com mudan√ßas no sistema** e permitir que o software evolua sem muita dor.\n\nNo que tange a legibilidade do c√≥digo, **as abstra√ß√µes devem tornar o c√≥digo mais leg√≠vel e n√£o o contr√°rio**.\n\n## Para concluir\n\nCriar abstra√ß√µes √© complicado e requer um bom entendimento do problema a ser resolvido. Se uma abstra√ß√£o n√£o for bem projetada, ela pode acabar sendo mais dif√≠cil de entender e manter do que o pr√≥prio c√≥digo duplicado.\n\nNo entanto, isso n√£o significa que a duplica√ß√£o de c√≥digo seja a melhor alternativa. A duplica√ß√£o pode levar a problemas de manuten√ß√£o, como corre√ß√µes duplicadas ou c√≥digo obsoleto, al√©m de dificultar a leitura e a compreens√£o do c√≥digo. A duplica√ß√£o aumenta o risco de erros, pois, se uma corre√ß√£o √© feita em um lugar, pode ser esquecido de ser feito em outro lugar onde o c√≥digo √© duplicado.\n\nA solu√ß√£o para evitar a duplica√ß√£o de c√≥digo e ainda assim criar abstra√ß√µes √∫teis √© encontrar o equil√≠brio certo entre abstra√ß√£o e detalhes de implementa√ß√£o. √â importante pensar em como a abstra√ß√£o pode ser √∫til no longo prazo e se ela pode ser adaptada facilmente para futuras mudan√ßas no sistema. √â importante tamb√©m criar abstra√ß√µes que sejam simples, claras e facilmente compreens√≠veis.\n\n## Refer√™ncias\n\n- [The Pragmatic Programmer](https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)\n- [Refactoring](https://www.amazon.com.br/Refactoring-Improving-Design-Existing-Code/dp/0134757599/ref=pd_lpo_1?pd_rd_w=y2LPp&content-id=amzn1.sym.036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&pf_rd_p=036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&pf_rd_r=T1Z6DP66YJS241C8ZYSX&pd_rd_wg=NXa55&pd_rd_r=4883151e-42e5-403c-981f-c973bb258c03&pd_rd_i=0134757599&psc=1)\n- [AHA Programming](https://kentcdodds.com/blog/aha-programming)\n- [Stop trying to be so DRY, instead Write Everything Twice (WET)](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33)\n- [The Wrong Abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)\n\n",
            "url": "https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho",
            "title": "Preferir a duplica√ß√£o sobre a abstra√ß√£o √© realmente o melhor caminho ?",
            "summary": "A duplica√ß√£o de c√≥digo √© algo muito ruim, uma abstra√ß√£o confusa √© t√£o ruim quanto. Ent√£o qual seria a melhor abordagem para isso ?",
            "date_modified": "2023-05-29T01:45:54.431Z",
            "date_published": "2023-05-29T01:45:54.431Z",
            "author": {
                "name": "Maur√≠cio Witter",
                "url": "https://twitter.com/rwietter"
            },
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://rwietterc.xyz/blog/article/programacao-declarativa-por-que-voce-deveria-conhecer",
            "content_html": "> A pr√°tica da leitura cr√≠tica leva √† habilidade de reescrever, no que lhe concerne, leva a uma escrita melhor (The Elements of Programming Style).\n\n## Introdu√ß√£o\n\nSabemos que as linguagens de programa√ß√£o podem ser classificadas de diversas formas, por Paradigmas (Orienta√ß√£o a Objetos, Funcional, Procedural, L√≥gico, entre outros); tamb√©m podem ser classificadas por type system forte e fraco; pelo n√≠vel de abstra√ß√£o (Machine code, Low level Assembler ou High level); se s√£o compiladas ou interpretadas, ou ent√£o pelo estilo imperativo, ou declarativo. Esse √∫ltimo que iremos discutir neste artigo.\n\nEntender o que s√£o os estilos de programa√ß√£o, suas caracter√≠sticas e como se comportam vai ajudar voc√™ a entender melhor outros paradigmas como o Paradigma Funcional e L√≥gico, al√©m de que com essa abordagem, voc√™ poder√° se ater melhor ao design do seu c√≥digo e escrever melhor.\n\nVoc√™ j√° deve ter ouvido falar que a hist√≥ria da programa√ß√£o de computadores come√ßou com computadores eletromec√¢nicos ‚Äî ou voc√™ pode considerar at√© antes disso ‚Äî com a codifica√ß√£o de algoritmos por meio de cart√µes perfurados utilizando a √Ålgebra Booleana e Assembler l√° pelas d√©cadas de 30 e 40. As linguagens de programa√ß√£o comerciais tamb√©m come√ßaram a surgir nessas d√©cadas seguintes.\n\nMas quanto ao estilo de programa√ß√£o, quando surgiu ? Bom, o estilo imperativo foi o primeiro estilo de codifica√ß√£o que surgiu, com as primeiras linguagens de estudo short code, esse estilo foi difundido por muito tempo j√° que ele √© parecido com a nossa comunica√ß√£o, tal como uma receita de bolo. J√° o estilo declarativo n√£o se tem uma data ou evento espec√≠fico, mas surgiu em algum grau com a linguagem LISP (1958) e principalmente com o Prolog (1972), depois foi aprofundado em outras linguagens l√≥gicas e funcionais como o Haskell (1990).\n\nNo lado das linguagens imperativas temos, por exemplo, FORTRAN, ALGOL, Pascal, Ada e C entre outras, j√° no lado da linguagens declarativas temos, por exemplo: HTML, CSS, YAML e SQL. √â v√°lido lembrar que as linguagens JavaScript, Java, PHP e Rust, por exemplo, seguem o paradigma imperativo mas incluem abstra√ß√µes que voc√™ pode utilizar para tornar seu c√≥digo mais declarativo.\n\n## Estilo de Programa√ß√£o Imperativo\n\nO estilo imperativo concentra-se em como executar o c√≥digo detalhe a detalhe e define o fluxo de controle de como instru√ß√µes alteram o estado de um programa. Para ficar mais claro, o c√≥digo imperativo ordena comandos ao computador, diz exatamente o que precisa fazer, como precisa fazer e em que ordem exata precisa executar, de tal modo que n√£o h√° abstra√ß√µes.\n\nA exemplo, o c√≥digo abaixo √© um algoritmo de ordena√ß√£o chamado de bubble Sort que percorre o array N¬≤ vezes fazendo a troca dos elementos at√© orden√°-lo completamente. Nesse c√≥digo h√° a constru√ß√£o da l√≥gica e fluxo de controle, al√©m da mutabilidade do array.\n\n![buble sort](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0a640f32-3aa6-4420-a048-16e4174e1a81_1348x1350.png)\n\nO c√≥digo imperativo serve a prop√≥sitos espec√≠ficos como a programa√ß√£o de c√≥digo de baixo n√≠vel para o qual existem poucas ou nenhuma abstra√ß√£o. Na maioria das vezes, tal estilo √© verboso, ruim para depurar, ler e para dar manuten√ß√£o, especialmente em grandes sistemas e equipes. Em um c√≥digo imperativo h√° muitos loops, condicionais e muta√ß√µes de estado que facilmente resultam em bugs.\n\nAssim sendo, a programa√ß√£o imperativa √© mais adequada para tarefas onde √© importante controlar o estado do programa e gerenciar o fluxo de execu√ß√£o. Mas, vale ressaltar que a programa√ß√£o imperativa pode ser dif√≠cil de paralelizar.\n\nVamos a um exemplo pr√°tico onde utilizarei a linguagem Typescript. Vamos calcular o fatorial de um n√∫mero natural positivo, cuja f√≥rmula est√° na imagem abaixo.\n\n![fatorail](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff5c2b102-a99c-45d4-a8ee-71d106821de5_487x157.png)\n\nPrimeiramente, temos um c√≥digo imperativo, onde avaliamos se N √© menor ou igual a zero e retornamos 1, do contr√°rio fazemos um loop at√© N-1 e multiplicamos o valor de N pelo √≠ndice fazendo a mutabilidade de N, ao final retornamos N. Perceba que nesse c√≥digo n√≥s programamos a l√≥gica de calcular o fatorial de N, mas tamb√©m programamos o fluxo de controle.\n\n![fatorial imperativo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F36ca5586-ae84-49f3-9be8-23b7b7e716d9_1040x630.png)\n\nVejamos agora um exemplo de um fatorial que utiliza um conceito da programa√ß√£o funcional que se chama recurs√£o, que nada mais √© do que o processo de chamar uma fun√ß√£o dentro dela mesma at√© que uma condi√ß√£o interrompa a execu√ß√£o. Nesse c√≥digo abaixo do fatorial com recurs√£o, n√≥s abstra√≠mos o fluxo de controle e definimos apenas a l√≥gica do algoritmo. Primeiramente, temos a mesma condi√ß√£o de retornar 1 se o N for negativo ou igual a zero e depois retornamos N multiplicado pelo valor retornado pela chamada recursiva decrementando N em -1, isso ser√° repetido at√© que N seja zero. Perceba que economizamos linhas de c√≥digo e ficou bem mais leg√≠vel.\n\n![fatorial recursivo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5163b037-876f-43f8-a9b0-b78f597733c3_1040x450.png)\n\nMais a frente veremos outros exemplos utilizando outras abstra√ß√µes que tornam o c√≥digo imut√°vel e conciso.\n\n### Caracter√≠sticas do c√≥digo Imperativo\n- Execu√ß√£o sequencial;\n- Estado mut√°vel;\n- Gerenciamento manual de mem√≥ria;\n- N√£o-determin√≠stico.\n\n### Vantagens\n- Dom√≠nio expl√≠cito sobre o fluxo de controle;\n- Efici√™ncia em uso de mem√≥ria (se utilizado corretamente);\n\n### Desvantagens\n- C√≥digo verboso;\n- Mutabilidade de estado;\n- Efeitos colaterais.\n\n## Estilo de Programa√ß√£o Declarativo\n\nO estilo declarativo, por outro lado, √© um modelo de abstra√ß√£o de alto n√≠vel que est√° mais pr√≥ximo do idioma ingl√™s, tal que foi seu objetivo inicial. Nesse estilo, o programador vai declarar o que deve ser computado ao inv√©s de como deve ser computado, vamos delegar a implementa√ß√£o de controle para a linguagem, para assim direcionar nossos esfor√ßos de programa√ß√£o e manuten√ß√£o para a l√≥gica e computabilidade.\n\nMuitas linguagens que aplicam esse estilo tentam minimizar ou eliminar os efeitos colaterais descrevendo o que o programa deve realizar em termos do dom√≠nio do problema, em vez de descrever como realiz√°-lo como uma sequ√™ncia das primitivas da linguagem de programa√ß√£o.\n\nConforme R. Kowalski em Communications of the ACM, Volume 22, Issue 7, July 1979, um algoritmo √© composto pela l√≥gica e pelo fluxo de controle. Na programa√ß√£o declarativa, a linguagem tende a abstrair a fluxo de controle e deixar para o programador desenvolver a l√≥gica.\n\n![algorithm](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F649d082d-40e8-4567-b23f-3779291ec802_452x59.png)\n\nLloyd, JW. no artigo Practical advantages of declarative programming, explica que a programa√ß√£o declarativa pode ser entendida como ‚Äúforte‚Äù e ‚Äúfraca‚Äù. Isto √©, no sentido ‚Äúforte‚Äù, o programador s√≥ fornece a l√≥gica do que precisa e no sentido ‚Äúfraco‚Äù, o programador precisa fornecer a l√≥gica e estender o fluxo de controle para computar o resultado esperado.\n\nO paralelismo √© um dos pilares da programa√ß√£o declarativa, assim como a abstra√ß√£o. A avalia√ß√£o do resultado deve depender exclusivamente da entrada, pois dessa forma, evita-se o acoplamento e elimina efeitos colaterais.\n\n![pilares da programa√ß√£o declarativa](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6c5f0443-0982-4134-bbd1-fd97b6465138_689x396.png)\n\n### Caracter√≠sticas do c√≥digo Declarativo\n- Stateless (estado interno n√£o √© relembrado entre chamadas);\n- Determin√≠stico (as mesmas chamadas produzem os mesmos resultados);\n- Paralelismo (execu√ß√£o de m√∫ltiplas tarefas simultaneamente);\n- Transpar√™ncia Referencial (uma express√£o pode ser substitu√≠da por seu valor sem afetar o comportamento);\n- Modelo sem√¢ntico claro e conciso;\n- Abstra√ß√µes de alto n√≠vel;\n- Independ√™ncia.\n\n### Vantagens\n- Legibilidade;\n- Concis√£o;\n- Recupera√ß√£o de erros;\n- Reutiliza√ß√£o;\n- Comutatividade;\n- Sem efeitos colaterais;\n- Idempot√™ncia.\n\n### Desvantagens\n- Baixo n√≠vel de controle;\n- Dificuldades de programa√ß√£o com estado (Stateful).\n\nT√°, entendi que tem benef√≠cios e tal. Mas, programar declarativamente significa apenas remover loops e condicionais do c√≥digo ? √â claro que n√£o, voc√™ pode aplicar em diversas situa√ß√µes, lembre-se que programa√ß√£o declarativa n√£o √© apenas sobre abstra√ß√£o, mas sobre legibilidade tamb√©m.\n\nNo exemplo abaixo temos um c√≥digo que faz stream de um arquivo CSV. O c√≥digo faz a convers√£o de um Node Stream para Web Stream. Primeiro, usamos um objeto Transform para converter o CSV em JSON e coloc√°-lo na fila para o pr√≥ximo Transform pegar os peda√ßos de JSON e filtrar as propriedades. Por √∫ltimo, criamos um Writable Stream para escrever os dados na resposta da requisi√ß√£o. Perceba que esse c√≥digo est√° bem ruim de ler, pois n√£o da para ter muita no√ß√£o do que faz o que a√≠.\n\n![streams imperativo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb60a4836-82ae-494c-8636-7ce68198187e_1394x1440.png)\n\nAgora, veremos uma maneira mais declarativa de fazer o mesmo c√≥digo acima. Os passos seguem os mesmos, a diferen√ßa √© que dividimos o c√≥digo e adicionamos mais legibilidade a ele. Primeiramente, escrevemos cada fun√ß√£o com a sua devida responsabilidade.\n\n![streams fun√ß√µes](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb5303173-bd1b-41a6-8a4c-472286613aea_1840x1666.png)\n\nAgora criamos o pipeline chamando as fun√ß√µes e repassando o resultado de uma fun√ß√£o para a pr√≥xima. Convenhamos que, agora voc√™ bate o olho no c√≥digo abaixo e j√° sabe o que ele faz, n√© ? Muito diferente do que aquele c√≥digo anterior.\n\n![streams pipeline](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F774a8622-501d-4609-ab90-1fa4fe6711d2_1040x450.png)\n\nA prop√≥sito, se quiser entender mais sobre streams, cola nesse [v√≠deo do Erick Wendel](https://www.youtube.com/watch?v=-IpRYbL4yMk&feature=youtu.be), do qual esse exemplo foi tirado.\n\n## Use Cases\n\nVoc√™ como Engenheiro de Software precisa conhecer bem as diversas classifica√ß√µes de linguagens e suas tecnologias para fazer boas escolhas e evitar tempo e dinheiro perdido. Na Engenharia de Software n√£o existe bala de prata, portanto √© necess√°rio conhecer as carater√≠sticas em geral. Aqui est√£o alguns casos de uso para cada estilo, embora existem muitos outros cen√°rios.\n\n### Estilo Imperativo\n\n- Sistemas de baixo n√≠vel: programa√ß√£o de sistemas de baixo n√≠vel, como drivers de dispositivo, sistemas operacionais e firmware. Essas tarefas requerem manipula√ß√£o direta de locais de mem√≥ria e registros de hardware, sendo melhor realizado usando um estilo imperativo.\n- Jogos e simula√ß√µes: jogos e simula√ß√µes geralmente envolvem algoritmos complexos e atualiza√ß√µes em tempo real, sendo mais f√°ceis de expressar usando um estilo imperativo. A programa√ß√£o imperativa fornece controle expl√≠cito sobre o fluxo do programa, tornando mais f√°cil escrever mecanismos de jogo eficientes e simula√ß√µes f√≠sicas.\n- Opera√ß√µes de E/S: a programa√ß√£o imperativa √© adequada para tarefas que envolvem muitos estados mut√°veis ‚Äã‚Äãe efeitos colaterais, como opera√ß√µes de E/S. Programas imperativos podem manipular diretamente locais de mem√≥ria e registros de dispositivos, tornando-os adequados para essas tarefas.\n\n### Estilo Declarativo\n\n- Desenvolvimento Web: a programa√ß√£o declarativa √© frequentemente usada no desenvolvimento Web, onde HTML, CSS e outras linguagens de marca√ß√£o s√£o usadas para definir a estrutura e a apar√™ncia das p√°ginas da Web. A programa√ß√£o declarativa permite que os desenvolvedores especifiquem a apar√™ncia da p√°gina, em vez de como obter essa apar√™ncia.\n- Processamento de dados: a programa√ß√£o declarativa √© adequada para tarefas de processamento de dados, como consultar bancos de dados e manipular grandes conjuntos de dados. Linguagens de programa√ß√£o declarativas como SQL fornecem uma interface de alto n√≠vel para interagir com dados, tornando mais f√°cil escrever consultas e transforma√ß√µes complexas.\n- Programa√ß√£o funcional: a programa√ß√£o funcional enfatiza o uso de fun√ß√µes puras e estruturas de dados imut√°veis. A programa√ß√£o funcional √© adequada para tarefas que exigem muita simultaneidade ou paralelismo, pois fun√ß√µes puras n√£o t√™m efeitos colaterais e podem ser executadas em paralelo com seguran√ßa.\n\n## Estado da Arte\n\n> A crescente popularidade das linguagens de programa√ß√£o declarativas decorre da simplicidade inerente do paradigma, cujo alto n√≠vel de abstra√ß√£o garante estilos de programa√ß√£o leg√≠veis por humanos. ‚Äî MOTTOLA A.. Design and implementation of a declarative programming language in a reactive environment. 2005.\n\nMuitas das linguagens imperativas come√ßaram a trazer novos recursos na √∫ltima d√©cada para o estilo declarativo. Um exemplo √© o Java 8 que trouce uma nova API para Streams para operar em cole√ß√µes usando express√µes lambda abstraindo o c√≥digo imperativo, inclusive voc√™ pode encontrar uma compara√ß√£o aqui.\n\nNo Front-end tamb√©m ganhamos muito mais produtividade e seguran√ßa com os frameworks declarativos que surgiram nos √∫ltimos anos, como o React, o Vue, o Angular, o Next, o Nuxt entre outros.\n\nNa √°rea de cloud-computing, v√°rias ferramentas no estilo declarativo como o Terraform, Ansible, Docker, Kubernets auxiliam a colocar aplica√ß√µes em produ√ß√£o com escalabilidade, seguran√ßa e confiabilidade, fazendo o CI/CD.\n\n## Conclus√£o\n\nN√£o existe de fato uma linguagem puramente declarativa, o que torna um c√≥digo declarativo ou imperativo √© como ele √© codificado. As linguagens que oferecem maiores recursos para programar no estilo declarativo s√£o linguagens com os paradigmas l√≥gico e funcional, pois se aproximam mais das caracter√≠sticas do estilo declarativo, embora o estilo depende da sua codifica√ß√£o como o uso de abstra√ß√µes, imutabilidade, determinismo e transpar√™ncia referencial.\n\nPortanto, pense na hora de programar que seu algoritmo precisa de um l√≥gica e um fluxo de controle, a partir da√≠, procure recursos na sua linguagem que abstraiam o fluxo de controle e deixe sob sua responsabilidade a implementa√ß√£o da l√≥gica. Os benef√≠cios disso s√£o melhor legibilidade e seguran√ßa, pois voc√™ abstraiu detalhes menores de controle e tamb√©m ganha interoperabilidade.\n\n√Ä medida que a programa√ß√£o declarativa continua a evoluir, √© prov√°vel que ela desempenhe um papel cada vez mais importante no futuro do desenvolvimento de software. Portanto, aprender sobre programa√ß√£o declarativa pode ser um investimento valioso para qualquer desenvolvedor que deseja melhorar sua habilidade em criar c√≥digo de alta qualidade e eficiente.\n\nSe voc√™ chegou at√© aqui, espero que tenha tido uma √≥tima leitura e que esse conte√∫do possa ter lhe ajudado de alguma forma. Obrigado por ler! Qualquer d√∫vida, agrega√ß√£o ou corre√ß√£o, deixe nos coment√°rios üíö\n\n## Refer√™ncias\n\n- [Declarative Programming](https://en.wikipedia.org/wiki/Declarative_programming#:~:text=Declarative%20programming%20is%20a%20non,by%20a%20declarative%20programming%20style.)\n- [Algorithm = logic + control](https://dl.acm.org/doi/10.1145/359131.359136)\n- [A Note on Declarative Programming Paradigms and the Future of Definitional Programming](https://www.cse.chalmers.se/~oloft/Papers/wm96.pdf)\n- [Practical advantages of declarative programming](https://research-information.bris.ac.uk/en/publications/practical-advantages-of-declarative-programming)\n- [CodeDocs - Declarative programming](https://codedocs.org/what-is/declarative-programming)\n- [Imperative Programming in Depth](https://blog.ndepend.com/imperative-programming-in-depth/)",
            "url": "https://rwietterc.xyz/blog/article/programacao-declarativa-por-que-voce-deveria-conhecer",
            "title": "Programa√ß√£o declarativa: por que voc√™ deveria conhecer ?",
            "summary": "Programa√ß√£o declarativa √© uma abordagem leg√≠vel, melhor de manter e paralelizar, que pode melhorar em muitos n√≠veis o seu c√≥digo.",
            "date_modified": "2023-02-25T01:22:12.570Z",
            "date_published": "2023-02-25T01:22:12.570Z",
            "author": {
                "name": "Maur√≠cio Witter",
                "url": "https://twitter.com/rwietter"
            },
            "tags": [
                "tech"
            ]
        },
        {
            "id": "https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle",
            "content_html": "### Introdu√ß√£o\n\nOl√° üëã\n\nHoje vamos falar de fluxos unidirecional e bidirecional no Nextjs. Por padr√£o, no React, os dados fluem de uma maneira: do *owner* para o *child*, ou seja, no fluxo unidirecional, mas por vezes precisamos acessar determinada fun√ß√£o ou realizar uma mudan√ßa de estado em um componente *child* pelo componente *owner*, isto √©, de forma bidirecional, expondo um dado do componente inferior para o superior.\n\n![fluxo bidirecional de dados dos componentes React. Componente owner passando uma propriedade ref para o componente child](https://raw.githubusercontent.com/rwietter/gatsby-blog/master/static/bidirecional.png)\n\nPara resolver isso, podemos elevar o estado (*Lifting State Up*) de um componente *child* para um componente *owner* que ir√° conter a l√≥gica do componente *child*. Outra forma √© utilizar a *Context API* ou outro gerenciador de estado global para compartilhamento de estado.  Mas, tamb√©m podemos expor uma fun√ß√£o ou estado para o componente *owner* por meio do *hook* `useImperativeHandle` e o *hook* `useRef` passando a refer√™ncia da propriedade para o componente *owner*. Vamos ver como isso funciona.\n\nConforme a documenta√ß√£o do React diz sobre o *hook* `useImperativeHandle`:\n\n> O *hook* `useImperativeHandle`¬†personaliza o valor da inst√¢ncia que est√° exposta aos componentes *owner* ao usar¬†`ref`. Como sempre, na maioria dos casos, seria bom evitar um c√≥digo imperativo usando refs.\n\nE sobre o *hook* `useRef`:\n\n> `useRef`¬†retorna um objeto¬†`ref`¬†mut√°vel, no qual a propriedade¬†`current`¬†√© inicializada para o argumento passado (`initialValue`). O objeto retornado persistir√° durante todo o ciclo de vida do componente.\n\nOu seja, o *hook* `useRef` cria um objeto mut√°vel que recebe um valor inicial no qual podemos mudar durante o ciclo de vida do componente, j√° o *hook*  `useImperativeHandle` vai nos ajudar a expor nossa propriedade para o componente superior de forma imperativa utilizando essa refer√™ncia.\n\n### Vamos ao exemplo pr√°tico\n\nVamos come√ßar criando um *app* com o *framework* *Nextjs*. Rode no seu terminal os comandos abaixo para criar o projeto, em seguida entre no diret√≥rio e execute a aplica√ß√£o.\n\n```shell\n# crie o projeto\nyarn create next-app --typescript\n\n# entre no diret√≥ria criado\ncd my-app\n\n# compila e executa o projeto em localhost\nyarn dev\n\n# abra no navegador o endere√ßo http://localhost:3000\n```\n\nProjeto criado! Agora, vamos at√© o `index.tsx` em `/pages/index.tsx` e vamos remover o c√≥digo desnecess√°rio, deixe como no exemplo abaixo.\n\n```tsx\nimport type { NextPage } from 'next'\n\nconst Home: NextPage = () => {\n  return (\n    <div>\n \n    </div>\n  )\n}\n\nexport default Home\n```\n\nVamos criar nosso componente `Modal`. Crie um diret√≥rio `components` na raiz do projeto e dentro dele um diret√≥rio `modal` e crie um arquivo `index.tsx`. Dentro do componente modal adicione uma `label` e um `input` com a l√≥gica de abrir o modal quando o estado for verdadeiro (*Short Circuit Evaluation*).\n\n```tsx\n// components/modal/index.tsx\nimport { useState } from \"react\";\n\nconst Modal: React.FC = () => {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  return (\n    <>\n      {isModalOpen && (\n        <div className=\"modal\">\n          <label htmlFor=\"nome\">Qual o seu nome ?</label>\n          <input name=\"nome\" />\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default Modal;\n```\n\nVamos importar o `Modal` no componente `Home` e adicionar um bot√£o logo abaixo que vai disparar um evento ao receber um `click`. Esse evento precisa mudar o estado do modal para `true` para que seja exibido em tela. Logo, precisamos referenciar a fun√ß√£o que troca o estado do modal para o componente `Home`.\n\n```tsx\nimport type { NextPage } from 'next'\nimport Modal from '../components/modal'\n\nconst Home: NextPage = () => {\n  return (\n    <main>\n      <Modal />\n      <button onClick={() => {}} className=\"open-modal-button\">\n        Open Modal\n      </button>\n    </main>\n  )\n}\n\nexport default Home\n```\n\nAntes vamos adicionar um estilo ao modal. Crie um arquivo de estilo `styles/modal.css`, esse estilo ir√° posicionar o modal sobre os outros elementos, centralizar seus componentes e adicionar uma largura e altura. Voc√™ pode copiar o CSS nesse [link](https://github.com/rwietter/blog-posts/blob/main/my-app/styles/modal.css).\n\nNo estilo `global.css` adicione o c√≥digo abaixo para centralizar o conte√∫do.\n\n```css\n/* styles/global.css */\nmain {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n```\n\nAgora basta importar o arquivo `modal.css`em `pages/_app.tsx`. Dessa forma o estilo j√° ser√° aplicado ao nosso componente `Modal`.\n\n```tsx\n// pages/_app.tsx\nimport '../styles/globals.css';\nimport '../styles/modal.css';\n```\n\nAgora precisamos fazer o fluxo inverso, vamos referenciar a fun√ß√£o que vai alterar o estado para que o componente *owner* possa acessar. No modal precisamos receber a refer√™ncia que ser√° criada no componente *owner*, essa refer√™ncia √© obtida como segundo par√¢metro, tamb√©m vamos adicionar o **tipo** aos nossos par√¢metros com *generic types*.  Tamb√©m, vamos expor a fun√ß√£o `handleOpenModal` com o *hook* `useImperativeHandle`, como primeiro argumento ele recebe a refer√™ncia criada no *owner*, como segundo argumento uma *callback* que ir√° retornar um objeto com nossa fun√ß√£o que queremos acessar pela refer√™ncia criada no *owner*. Por fim, vamos exportar o componente como argumento da fun√ß√£o `forwardRef`, essa fun√ß√£o ir√° encaminhar a refer√™ncia ao componente *owner*.\n\n```tsx\nimport {\n  forwardRef,\n  ForwardRefRenderFunction,\n  ReactNode,\n  useImperativeHandle,\n  useState,\n} from \"react\";\n\ninterface ModalProps {\n  children?: ReactNode;\n}\n\nconst Modal: ForwardRefRenderFunction<ModalRef, ModalProps> = (props, ref) => {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const handleOpenModal = () => setIsModalOpen((state) => !state);\n  \n  useImperativeHandle(ref, () => ({\n    handleOpenModal,\n  }));\n\n  return (\n    <>\n      {/* ... */}\n    </>\n  )\n}\n\nexport default forwardRef(Modal);\n```\n\nAgora, no componente `Home`, precisamos criar a `ref` e repassar para o componente modal.  Utilizamos o *hook* `useRef` para criar uma `ref` e passamos como *generic type* a interface `ModalRef` que espec√≠fica a fun√ß√£o que iremos referenciar. Exporte essa interface e importe no componente Modal, pois precisamos adicionar o *type* que recebemos como atributo do componente. \n\n```tsx\nexport interface ModalRef {\n  handleOpenModal: () => void;\n}\n\nconst Home: NextPage = () => {\n  const modalRef = useRef<ModalRef>(null);\n\n  return (\n    <>\n      <Modal ref={modalRef} />\n      <button onClick={() => {}}>Open Modal</button>\n    </>\n  )\n}\n\nexport default Home;\n```\n\nAinda no componente `Home`, s√≥ precisamos criar uma fun√ß√£o que ir√° receber a refer√™ncia da fun√ß√£o do `Modal` e repassar para a propriedade `onClick`. Feito isso, j√° iremos ter o modal funcional. \n\n```tsx\nconst Home: NextPage = () => {\n  const modalRef = useRef<ModalRef>(null);\n  const handleOpenModal = () => modalRef.current?.handleOpenModal();\n\n  return (\n    <>\n      <Modal ref={modalRef} />\n      <button onClick={handleOpenModal}>Open Modal</button>\n    </>\n  )\n}\n```\n\nPara finalizar, vamos adicionar um bot√£o de `close` no modal para fechar quando estiver aberto. \n\n```tsx\nreturn (\n  <>\n    {isModalOpen && (\n      <div className=\"modal\">\n        <label htmlFor=\"nome\">Qual o seu nome ?</label>\n        <input name=\"nome\" />\n        <button onClick={handleOpenModal}>Close</button>\n      </div>\n    )}\n  </>\n);\n```\n\n### Conclus√£o\n\nEssa √© uma forma simples de alterar um estado quando n√£o podemos ou n√£o queremos criar a l√≥gica de uma funcionalidade em um componente que n√£o precisa saber dessa funcionalidade ou n√£o queremos utilizar um gerenciador de estado.  N√£o √© muito comum, nem recomend√°vel utilizar c√≥digo imperativo, mas quando necess√°rio pode ser muito √∫til :)\n\nAt√© mais ‚öõ üëã\n\n- - -\n\n### Refer√™ncias\n\n* [Hook useImperativeHandle](https://pt-br.reactjs.org/docs/hooks-reference.html#useimperativehandle)\n* [Hook useRef](https://pt-br.reactjs.org/docs/hooks-reference.html#useref)\n* [ForwardRef](https://pt-br.reactjs.org/docs/react-api.html#reactforwardref)\n* [Reposit√≥rio do projeto](https://github.com/rwietter/blog-posts/tree/main/my-app)",
            "url": "https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle",
            "title": "Fluxo bidirecional no React com useImperativeHandle",
            "summary": "Expondo uma fun√ß√£o de um componente child para o componente owner no React",
            "date_modified": "2022-04-25T11:59:22.126Z",
            "date_published": "2022-04-25T11:59:22.126Z",
            "author": {
                "name": "Maur√≠cio Witter",
                "url": "https://twitter.com/rwietter"
            },
            "tags": [
                "tech"
            ]
        }
    ]
}